#include <fstream>
#include <iostream>
#include <string>
#include <set>

using namespace std;

// The script generates the sets with different material properties of the structure based on the .ele file generated by tetgen(with regions labeled with 0-index)


void genRegion(string FileName);
void genBoundary(string FileName);

int main (int argc, char *argv[])
{

   if (argc <= 1){
       cerr << "Must pass in input file name!" << endl;
       return 1;
   }
   string FileName(argv[1]);
   genRegion(FileName);
   genBoundary(FileName);
   
   return 0;
}


void genRegion(string FileName){
   ifstream Infile;
   Infile.open(FileName + ".ele");
   int nRegion;
   cout << "Number of regions in the structure" << endl;
   cin >> nRegion;
   ofstream ofs[nRegion];  
   for(int i = 0; i < nRegion; i++){
       ofs[i].open(FileName + "_Set" + char('0'+i) + ".txt");
   } 
   int nEle, Element, Region;
   Infile >> nEle;
   Infile >> Element;
   Infile >> Element;
   int count[2]={0,0};
   for(int i =0; i < nEle; i++){
       Infile >> Element;
       Infile >> Region;
       Infile >> Region;
       Infile >> Region;
       Infile >> Region;
       Infile >> Region;
       count[Region]++;
       ofs[Region] << Element << ",";
       if(count[Region]%10 == 0 && count[Region] != 0){
          ofs[Region] << endl;
       }
   }
}
   
   
void genBoundary(string FileName){
   ifstream Infile;
   Infile.open(FileName + ".face");
   int nRegion;
   int nBoundary;
   cout << "Number of boundaries in the structure" << endl;
   cin >> nBoundary;
   ofstream ofs[nBoundary];  
   for(int i = 0; i < nBoundary; i++){
       ofs[i].open(FileName + "_Boundary" + char('0'+i) + ".txt");
   } 
   int nFace, v1, v2,v3, Boundary;
   Infile >> nFace;
   Infile >> v1;
   std::set<int> bound[nBoundary];
   for(int i =0; i < nFace; i++){
       Infile >> v1;
       Infile >> v1;
       Infile >> v2;
       Infile >> v3;
       Infile >> Boundary;
       if(Boundary>0){
          bound[Boundary-1].insert(v1);
          bound[Boundary-1].insert(v2);
          bound[Boundary-1].insert(v3);
       }
   }
   
   for(int i=0; i<nBoundary; i++){
       set<int>::iterator it;
       for(it = bound[i].begin(); it!=bound[i].end(); it++){
           ofs[i] << *it << endl;
       }
   }
}
